import{_ as a,o as e,c as i,V as l}from"./chunks/framework.15bfdeb5.js";const u=JSON.parse('{"title":"常见知识点","description":"","frontmatter":{"title":"常见知识点","date":"2018-05-19T00:00:00.000Z","tags":["面试"],"categories":["interview"],"author":"尘丶骁"},"headers":[],"relativePath":"views/interview/常见知识点.md","filePath":"views/interview/常见知识点.md"}'),r={name:"views/interview/常见知识点.md"},t=l('<h2 id="函数柯里化" tabindex="-1">函数柯里化 <a class="header-anchor" href="#函数柯里化" aria-label="Permalink to &quot;函数柯里化&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">特点</p><ol><li>参数复用</li><li>提前返回</li><li>延迟执行</li></ol></div><h1 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h1><h2 id="网站访问的过程" tabindex="-1">网站访问的过程 <a class="header-anchor" href="#网站访问的过程" aria-label="Permalink to &quot;网站访问的过程&quot;">​</a></h2><ol><li>用户操作浏览器访问，浏览器向服务器发出一个 HTTP 请求</li><li>服务器接收到 HTTP 请求，Web Server 进行相应的初步处理，使用服务器脚本生成页面</li><li>服务器脚本（利用Web Framework）调用本地和客户端传来的数据，生成页面</li><li>Web Server 将生成的页面作为 HTTP 响应的 body，根据不同的处理结果生成 HTTP header，发回给客户端</li><li>客户端（浏览器）接收到 HTTP 响应，通常第一个请求得到的 HTTP 响应的 body 里是 HTML 代码，于是对 HTML 代码开始解析</li><li>解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向 Web Server 发送请求，Web Server 找到对应的文件，发送回来</li><li>浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步渲染，JS 代码也可能会对外观进行一定的处理</li><li>用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画</li><li>交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新，类似微博的新消息通知），一般不是跳转就是通过 JS 代码（响应某个动作或者定时）向 Web Server 发送请求，Web Server 再用服务器脚本进行处理（生成资源or写入数据之类的），把资源返回给客户端，客户端用得到的资源来实现动态效果或其他改变</li></ol><h2 id="浏览器的渲染过程" tabindex="-1">浏览器的渲染过程 <a class="header-anchor" href="#浏览器的渲染过程" aria-label="Permalink to &quot;浏览器的渲染过程&quot;">​</a></h2><ol><li>处理 HTML 标记并构建 DOM 树</li><li>处理 CSS 标记并构建 CSSOM 树</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上</li></ol><h3 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h3><p><strong>为什么css要放在head里面</strong></p><p>假设css放在body之后, 那就会产生元素在渲染一遍自己的默认样式之后又渲染一次css中的样式</p><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="加载资源优化" tabindex="-1">加载资源优化 <a class="header-anchor" href="#加载资源优化" aria-label="Permalink to &quot;加载资源优化&quot;">​</a></h3><ol><li>静态资源得压缩合并</li><li>静态资源缓存</li><li>使用CDN使资源加载更快</li><li>使用SSR</li></ol><h3 id="渲染优化" tabindex="-1">渲染优化 <a class="header-anchor" href="#渲染优化" aria-label="Permalink to &quot;渲染优化&quot;">​</a></h3><ol><li>CSS和JS的顺序</li><li>懒加载(图片懒加载, 下拉加载更多)</li><li>减少DOM查询和操作, 对DOM查询做缓存</li><li>事件节流</li></ol><h2 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h2><h3 id="_1-xss-跨站请求攻击" tabindex="-1">1. XSS(跨站请求攻击) <a class="header-anchor" href="#_1-xss-跨站请求攻击" aria-label="Permalink to &quot;1. XSS(跨站请求攻击)&quot;">​</a></h3><p>原理: 通常都是使用script标签来插入代码执行脚本, 获取用户信息等 解决: 使用转义</p><h3 id="_2-xsrf-跨站请求伪造" tabindex="-1">2. XSRF(跨站请求伪造) <a class="header-anchor" href="#_2-xsrf-跨站请求伪造" aria-label="Permalink to &quot;2. XSRF(跨站请求伪造)&quot;">​</a></h3><p>原理: 通常都是用img, script伪造付费接口等 解决: 增加验证手段, 指纹, 短信验证码</p>',20),o=[t];function s(h,n,d,c,S,_){return e(),i("div",null,o)}const m=a(r,[["render",s]]);export{u as __pageData,m as default};
